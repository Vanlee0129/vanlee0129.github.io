<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>超好用的图片浏览器Irfanview</title>
    <url>/Irfanview/</url>
    <content><![CDATA[<hr>
<p>再也不怕图片加载卡了。</p>
<p>系统自带的图片浏览器和国产的图片浏览器不是卡就是广告非常多，看着就烦。</p>
<p>所以，今天和大家推荐一款超好用的图片浏览器Irfanview，安装包仅3.37M。</p>
<p>非常的精致小巧，开图片基本是秒开，不快你砍我好伐。</p>
<blockquote>
<p><a href="https://www.irfanview.com/main_download_engl.htm">官网下载地址</a> </p>
</blockquote>
<p>安装教程如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9708361-4551655311d56e73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="057a1dfd746f63d3150c5b0caaff550.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9708361-94b83d114d54150c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="09d81ca29f65081146ebe778d691d7c.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9708361-2f04932a5140b62b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a3ee830de8dad48e10aead84e4b1c37.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9708361-977e0000f6bb75ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="41bf980aef3cda64f5a3be62be31a35.png"></p>
<p>其余全部狂点下一步就行了  </p>
<p>我保证开图片再也不卡了</p>
]]></content>
      <categories>
        <category>实用工具</category>
      </categories>
  </entry>
  <entry>
    <title>const</title>
    <url>/const/</url>
    <content><![CDATA[<p>首先来看看 MDN 的描述：</p>
<blockquote>
<p>const 声明创建一个常量，其作用域可以是全局或本地声明的块。 与 var 变量不同，全局常量不会变为 window 对象的属性。需要一个常数的初始化器；也就是说，您必须在声明的同一语句中指定它的值（这是有道理的，因为以后不能更改）。<br />const 声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容（例如，其参数）。<br />关于“暂存死区”的所有讨论都适用于 let 和 const。一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。</p>
</blockquote>
<p>从 MDN 的描述中可以看出 const 如果用来声明一个值，那么这个值是不可变的，相当于常量。</p>
<p>如果声明一个对象，那么可以修改对象的内容，从某种意义上来说是可变的。</p>
<p>考虑如下例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span> <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">    c: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b = &#123;<span class="attr">c</span>: <span class="number">2</span>&#125; <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line">b.c = <span class="number">2</span> <span class="comment">//不报错</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// &#123;c: 2&#125;</span></span><br></pre></td></tr></table></figure>

<p>当 a 初始化为 1 的时候，1 是值类型 Number，是直接存储在内存中的。而当 b 初始化为一个对象时，b 所储存的其实这个对象的内存地址，这个地址是一个值类型。</p>
<p>此时 b 是对这个对象的引用。</p>
<p>所以将{c: 2}赋值给 b 时其实是相当于把一个新的对象的内存地址赋值给 b 了，改变了 b 原本存储的值。</p>
<p>当直接通过字面量修改 c 的值为 2 时，其实修改的是这个对象本身的内容，并没有改变这个对象的内存地址，所以是不报错的。</p>
<blockquote>
<p>总结：const 声明的变量是不可变的，但是如果这个变量是一个引用类型，可以修改这个引用类型本身的内容。</p>
</blockquote>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝</title>
    <url>/deepCopy/</url>
    <content><![CDATA[<p>由于JS中的数据类型分为值类型和引用类型，所以对于引用类型来说变量储存的其实是地址而不是这个对象本身。考虑如下例子：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    b: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = a</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, c) <span class="comment">// &#123;b: 1&#125; &#123;b: 1&#125;</span></span><br><span class="line"></span><br><span class="line">a.b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// &#123;b: 2&#125;</span></span><br></pre></td></tr></table></figure>
<p>从上面例子可以看出a变化后c也跟着变了，显然这不是我们想要的结果。出现以上的原因是直接将a赋值给c是一种浅拷贝。实际上是将a所对应的地址赋值给了c。  </p>
<p>为了解决这个问题，我们需要深拷贝。对于以上例子我们可以采用以下办法：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> c = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))  </span><br></pre></td></tr></table></figure>

<p>但是这个方法有以下局限性：  </p>
<ul>
<li><p>他无法实现对函数 、RegExp等特殊对象的克隆</p>
</li>
<li><p>会抛弃对象的constructor,所有的构造函数会指向Object</p>
</li>
<li><p>对象有循环引用,会报错  </p>
</li>
</ul>
<p>在生产环境我们一般使用第三方库成熟的方法，但是核心原理其实是一样的。  </p>
<p>现在们来实现一个简版的深拷贝：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> deepCloneOne = <span class="function">(<span class="params">initalObj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> initalObj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> initalObj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> initalObj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> initalObj[key] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//对数组特殊处理</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(initalObj[key])) &#123;</span><br><span class="line">                <span class="comment">//用map方法返回新数组，将数组中的元素递归</span></span><br><span class="line">                obj[key] = initalObj[key].map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.deepCloneOne(item)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归返回新对象</span></span><br><span class="line">                obj[key] = <span class="built_in">this</span>.deepCloneOne(initalObj[key])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> initalObj[key] === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//返回新函数</span></span><br><span class="line">            obj[key] = initalObj[key].bind(obj)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//基本类型直接返回</span></span><br><span class="line">            obj[key] = initalObj[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span></span>&#125; obj </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCloneTwo</span>(<span class="params">obj = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//obj是null或者不是对象</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化返回结果</span></span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">        result = []</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="comment">//保证key不是原型的属性</span></span><br><span class="line">            <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">                <span class="comment">//递归调用</span></span><br><span class="line">                result[key] = deepCloneTwo(obj[key])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心思路就先判断这个对象是哪种对象，然后根据这种对象的特点去构造一个新的对象，用递归的方法将这个对象的所有属性都挨个赋给新对象。  </p>
<p>深拷贝产生的新对象和原来的对象没有一点关系，只是长得一样，但是是存储在一块新开辟的空间，两者之间不会互相影响。</p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker快速安装Jenkins</title>
    <url>/dockerInstallJenkins/</url>
    <content><![CDATA[<h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>CentOS Linux release 7.6.1810 (Core)<br>Docker version 19.03.12  </p>
<h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>我这里安装的版本是<code>jenkinsci/blueocean</code>，可以去这里获取你需要的版本: <a href="https://hub.docker.com/_/jenkins?tab=tags">dockerHub</a>，注意版本之间的区别。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker pull jenkinsci/blueocean</span></span><br></pre></td></tr></table></figure>

<h2 id="创建本地数据卷"><a href="#创建本地数据卷" class="headerlink" title="创建本地数据卷"></a>创建本地数据卷</h2><p>映射本地数据卷的路径为/data/jenkins_home/，想放别的地方可以自行修改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkdir -p /data/jenkins_home/</span></span><br></pre></td></tr></table></figure>
<p>需要修改下目录权限，因为当映射本地数据卷时，/data/jenkins_home/目录的拥有者为root用户，而容器中jenkins用户的 uid 为 1000。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> chown -R 1000:1000 /data/jenkins_home/</span></span><br></pre></td></tr></table></figure>
<h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker run -d --name jenkins -p 9021:8080 -p 50000:50000 -v /data/jenkins_home:/var/jenkins_home jenkins/jenkins:2.222.3-centos</span></span><br></pre></td></tr></table></figure>
<p><code>-d</code> 标识是让 docker 容器在后台运行<br><code>--name</code> 定义一个容器的名字，如果没有指定，那么会自动生成一个随机数字符串当做UUID<br><code>-p</code> 9021:8080 端口映射，不被占用的合法端口都可以使用，我用的9021<br><code>-p</code> 50000:50000 端口映射<br><code>-v</code> /data/jenkins_home:/var/jenkins_home 绑定一个数据卷，/data/jenkins_home是刚才创建的本地数据卷</p>
<h2 id="配置-Jenkins"><a href="#配置-Jenkins" class="headerlink" title="配置 Jenkins"></a>配置 Jenkins</h2><h3 id="打开-Jenkins"><a href="#打开-Jenkins" class="headerlink" title="打开 Jenkins"></a>打开 Jenkins</h3><p>通过浏览器访问 <code>http://xx.xx.xx.xx:9021/</code>（注意替换成你自己的IP和端口）进入初始页，如果 Jenkins 还没有启动完成，会显示如下内容<br><img src="https://ftp.bmp.ovh/imgs/2020/10/cd62632b22fa7dc1.png" alt="初始化界面"></p>
<h3 id="输入管理员密码"><a href="#输入管理员密码" class="headerlink" title="输入管理员密码"></a>输入管理员密码</h3><p><img src="https://ftp.bmp.ovh/imgs/2020/10/305ce3669e4731d4.png" alt="输入管理员密码"><br>这里要求输入初始的管理员密码，根据提示密码在/var/jenkins_home/secrets/initialAdminPassword这个文件中，注意这个路径是 Docker 容器中的，所以我们通过如下命令获取  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /data/jenkins_home/secrets/initialAdminPassword </span></span><br></pre></td></tr></table></figure>
<p>输入密码后，点击<code>继续</code>    </p>
<hr>
<p>到此Jenkins就安装完毕，安装插件时可以先换源再安装，不然速度会很慢 </p>
]]></content>
      <categories>
        <category>实用工具</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6中的let</title>
    <url>/es6-let/</url>
    <content><![CDATA[<p>let是ES6定义的新关键词，用于声明变量，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>let声明的变量不能重复声明，例如： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span> </span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span> <span class="comment">//Identifier &#x27;a&#x27; has already been declared</span></span><br></pre></td></tr></table></figure>
<p>let也可以不用初始化，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a)<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>let是块级作用域，可以解决for循环中变量泄露的问题，例如: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    arr.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(i)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    arr() <span class="comment">//打印10次10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面为什么输出10次10呢？因为为变量 i 在循环的每次迭代中都被共享了，意味着循环内创建的那些函数都拥有对于同一 变量的引用。在循环结束后，变量 i 的值会是 10 ，因此当 console.log(i) 被调用时， 每次都打印出 10 。  </p>
<p>现在用let改写这个例子： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    arr.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(i)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    arr() <span class="comment">//0-9</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>为什么let可以解决这个问题呢？因为在每次迭代中，let都会创建一个新的同名变量并对其进行初始化。在循环中 let 声明每次都创建了一个新的 i 变量，因此在循环内部创建的函数获得了各自的 i 副 本，而每个 i 副本的值都在每次循环迭代声明变量的时候被确定了。</p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>let</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的前端灰度发布方案</title>
    <url>/grayDeploy/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>灰度发布（又名金丝雀发布）是指在黑与白之间，能够平滑过渡的一种发布方式。在其上可以进行A/B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。  </p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>灰度发布的核心就是分流，一部分用户能看到，一部分用户看不到。所以主要实现的核心分流算法。在实现这个需求的时候，我想到了抽签。比如在1-100的数字中抽到1-30的用户进入beta版本，抽到31-100的用户进入stable版本。这样就相当于是30%的流量进入灰度版本。  </p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>首先实现产生1-100的整数的随机函数。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***************************************</span></span><br><span class="line"><span class="comment"> * 生成从minNum到maxNum的随机数。</span></span><br><span class="line"><span class="comment"> * 如果指定decimalNum个数，则生成指定小数位数的随机数</span></span><br><span class="line"><span class="comment"> * 如果不指定任何参数，则生成0-1之间的随机数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@minNum</span>：[数据类型是Integer]生成的随机数的最小值（minNum和maxNum可以调换位置）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maxNum</span>：[数据类型是Integer]生成的随机数的最大值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@decimalNum</span>：[数据类型是Integer]如果生成的是带有小数的随机数，则指定随机数的小数点后的位数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> ****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomNum</span>(<span class="params">maxNum, minNum, decimalNum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> max = <span class="number">0</span>,</span><br><span class="line">        min = <span class="number">0</span>;</span><br><span class="line">    minNum &lt;= maxNum ? ((min = minNum), (max = maxNum)) : ((min = maxNum), (max = minNum));</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>) + min);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">Math</span>.random() * (max - min) + min).toFixed(decimalNum);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.random();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后实现灰度流量的判断  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>灰度显示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>defaultLucky 灰度值，取值范围[0,1]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Boolean&#125;</span> </span>ture/false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isShowGray</span>(<span class="params">defaultLucky</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!lucky) lucky = defaultLucky;</span><br><span class="line">    <span class="keyword">var</span> num = randomNum(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="built_in">Number</span>(<span class="number">100</span> * lucky) &amp;&amp; num &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，简单的灰度方案就做好了。在进入页面时先调用<code>isShowGray</code>函数判断进入哪个方案。这样就可以做到简单的用户分流。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>v-if失效时强制刷新</title>
    <url>/forceUpdate/</url>
    <content><![CDATA[<p><code>v-if</code>动态计算时，如果数据层级太深可能导致<code>render</code>函数没有自动刷新，所以需要手动刷新。此时可以调用<code>this.$forceUpdate()</code>强制刷新。</p>
<p>使用示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.couponList[index].isSelected = <span class="literal">true</span></span><br><span class="line"><span class="comment">//赋值后调用强制刷新</span></span><br><span class="line"><span class="built_in">this</span>.$forceUpdate()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>v-if</tag>
      </tags>
  </entry>
  <entry>
    <title>使用node加解密DES-CBC</title>
    <url>/node-des/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了保护请求内容不被抓包软件暴露出来，很多产品都采用了请求加密的方式。DES-CBC就是一种对称加密方式。在网上查资料时发现node的资料不多，所以研究之后记录一下使用node加解密DES-CBC。  </p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>首先是加密函数：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>DES加密，以hex为例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>encodeTxt 待加密的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>key 秘钥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>iv 偏移量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">desEncode</span>(<span class="params">encodeTxt, key, iv</span>) </span>&#123;</span><br><span class="line">    key = key.length &gt;= <span class="number">8</span> ? key.slice(<span class="number">0</span>, <span class="number">8</span>) : key.concat(<span class="string">&#x27;0&#x27;</span>.repeat(<span class="number">8</span> - key.length))</span><br><span class="line">    iv = iv.length &gt;= <span class="number">8</span> ? iv.slice(<span class="number">0</span>, <span class="number">8</span>) : iv.concat(<span class="string">&#x27;0&#x27;</span>.repeat(<span class="number">8</span> - iv.length))</span><br><span class="line">    <span class="keyword">const</span> keyHex = Buffer.from(key)</span><br><span class="line">    <span class="keyword">const</span> ivHex = Buffer.from(iv)</span><br><span class="line">    <span class="keyword">const</span> encipher = crypto.createCipheriv(<span class="string">&#x27;des-cbc&#x27;</span>, keyHex, ivHex)</span><br><span class="line">    <span class="comment">//编码方式除了可以使用hex还可以使用base64。</span></span><br><span class="line">    <span class="keyword">let</span> encode = encipher.update(encodeTxt, <span class="string">&#x27;utf8&#x27;</span>, <span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">    encode += encipher.final(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> encode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解密函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>DES解密，要和加密方式对应起来</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>decodeTxt 待解密的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>key 秘钥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>iv 偏移量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">desDecode</span>(<span class="params">decodeTxt, key, iv</span>) </span>&#123;</span><br><span class="line">    key = key.length &gt;= <span class="number">8</span> ? key.slice(<span class="number">0</span>, <span class="number">8</span>) : key.concat(<span class="string">&#x27;0&#x27;</span>.repeat(<span class="number">8</span> - key.length))</span><br><span class="line">    iv = iv.length &gt;= <span class="number">8</span> ? iv.slice(<span class="number">0</span>, <span class="number">8</span>) : iv.concat(<span class="string">&#x27;0&#x27;</span>.repeat(<span class="number">8</span> - iv.length))</span><br><span class="line">    <span class="keyword">const</span> keyHex = Buffer.from(key)</span><br><span class="line">    <span class="keyword">const</span> ivHex = Buffer.from(iv)</span><br><span class="line">    <span class="keyword">const</span> decipher = crypto.createDecipheriv(<span class="string">&#x27;des-cbc&#x27;</span>, keyHex, ivHex)</span><br><span class="line">    <span class="keyword">let</span> decode = decipher.update(decodeTxt, <span class="string">&#x27;hex&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    decode += decipher.final(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> decodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在使用时要特别注意加密和解密的编码方式要对应起来，如果没有对应起来就会报错或者得不到结果。</p>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>des-cbc</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>npm发包记录</title>
    <url>/npm/</url>
    <content><![CDATA[<h2 id="注册-NPM-账号"><a href="#注册-NPM-账号" class="headerlink" title="注册 NPM 账号"></a>注册 NPM 账号</h2><p>首先去 npm 官网注册账号，注册地址<a href="https://www.npmjs.com/">https://www.npmjs.com/</a>。然后验证邮箱即注册完成。</p>
<h2 id="准备要发布的包"><a href="#准备要发布的包" class="headerlink" title="准备要发布的包"></a>准备要发布的包</h2><p>准备发布的包在开发好后要注意 package.json 中的如下信息：</p>
<ul>
<li>name 包名</li>
<li>version  版本号，更新版本时需要修改版本号</li>
<li>dependencies  包依赖</li>
</ul>
<h2 id="相关目录规范"><a href="#相关目录规范" class="headerlink" title="相关目录规范"></a>相关目录规范</h2><ul>
<li><code>src</code>：源码源文件。</li>
<li><code>lib</code>：依赖文件（没通过 npm，直接下载源码的那种）。</li>
<li><code>node_modules</code>：npm 依赖文件。</li>
<li><code>bin</code>：二进制可执行文件。</li>
<li><code>tests</code>：单元测试或集成测试文件。</li>
<li><code>docs</code>：文档、开发手册。</li>
<li><code>examples</code>：示例代码或项目。</li>
<li><code>build</code>：构建时所需文件。</li>
<li><code>dist</code>：打包后的输出目录。</li>
</ul>
<h2 id="查看-npm-源"><a href="#查看-npm-源" class="headerlink" title="查看 npm 源"></a>查看 npm 源</h2><p>一定要确保 npm 源为官方源<a href="https://registry.npmjs.org/">https://registry.npmjs.org</a>。如果要查看自己当前的源则使用：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure>

<p>如果是非官方源则使用如下命令调整：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org</span><br></pre></td></tr></table></figure>

<h2 id="开始发包"><a href="#开始发包" class="headerlink" title="开始发包"></a>开始发包</h2><p>首先在终端中登录 npm，使用命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm adduse</span><br></pre></td></tr></table></figure>

<p>登录完成后发布我们需要发布的包：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm publish --access public</span><br></pre></td></tr></table></figure>

<p>发布成功后可以看到如下信息：</p>
<p><a href="https://imgchr.com/i/rH5uy6"><img src="https://s3.ax1x.com/2020/12/29/rH5uy6.png" alt="发布成功"></a></p>
<h2 id="查看发布的包"><a href="#查看发布的包" class="headerlink" title="查看发布的包"></a>查看发布的包</h2><p>发包成后可以在<a href="https://www.npmjs.com/">https://www.npmjs.com/</a>中搜索刚刚发布的包，结果如下：</p>
<p><a href="https://imgchr.com/i/rH5QeO"><img src="https://s3.ax1x.com/2020/12/29/rH5QeO.png" alt="查看发布"></a></p>
<h2 id="使用发布的包"><a href="#使用发布的包" class="headerlink" title="使用发布的包"></a>使用发布的包</h2><p>首先在 Demo 中安装刚刚发布的包：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm i node-des-cbc</span><br></pre></td></tr></table></figure>

<p>然后验证包是否可用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> des = <span class="built_in">require</span>(<span class="string">&quot;node-des-cbc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(des);</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><a href="https://imgchr.com/i/rH5GYd"><img src="https://s3.ax1x.com/2020/12/29/rH5GYd.png" alt="发布结果"></a></p>
<p>发包所用代码地址： <a href="https://github.com/Vanlee0129/node-des-cbc">https://github.com/Vanlee0129/node-des-cbc</a></p>
<p>npm 官网地址: <a href="https://www.npmjs.com/package/node-des-cbc">https://www.npmjs.com/package/node-des-cbc</a></p>
]]></content>
      <categories>
        <category>开发相关</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>发包</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序分享API踩坑</title>
    <url>/onShareAppMessage/</url>
    <content><![CDATA[<p>微信小程序分享API <code>onShareAppMessage</code> 带的参数只能叫<code>id</code>，不能叫其他的，不然拿不到。  </p>
<p>使用时可以在单页面使用，也可以使用全局混入，一般来说我们都使用全局混入的方式去做。  </p>
<p>注意，这个函数是一个页面钩子函数，需要与onLoad等函数同级。  </p>
<p>使用示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//share.mixin.js</span></span><br><span class="line"><span class="keyword">export</span>  <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            share: &#123;</span><br><span class="line">                title: <span class="string">&#x27;你的标题&#x27;</span>,</span><br><span class="line">                path: <span class="string">&#x27;/pages/index/index&#x27;</span>,</span><br><span class="line">                imageUrl: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                desc: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    onShareAppMessage(res) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="comment">//标题</span></span><br><span class="line">            title: <span class="built_in">this</span>.share.title,</span><br><span class="line">            <span class="comment">//页面路径</span></span><br><span class="line">            path: <span class="built_in">this</span>.share.path,</span><br><span class="line">            <span class="comment">//分享后显示的图片的地址，默认为当前页面的截图</span></span><br><span class="line">            imageUrl: <span class="built_in">this</span>.share.imageUrl,</span><br><span class="line">            <span class="comment">//描述</span></span><br><span class="line">            desc: <span class="built_in">this</span>.share.desc,</span><br><span class="line">            <span class="comment">//内容</span></span><br><span class="line">            content: <span class="built_in">this</span>.share.content,</span><br><span class="line">            success(res) &#123;</span><br><span class="line">                uni.showToast(&#123;</span><br><span class="line">                    title: <span class="string">&#x27;分享成功&#x27;</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            fail(res) &#123;</span><br><span class="line">                uni.showToast(&#123;</span><br><span class="line">                    title: <span class="string">&#x27;分享失败&#x27;</span>,</span><br><span class="line">                    icon: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在页面中使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//example.vue</span></span><br><span class="line"><span class="keyword">async</span> onLoad(options) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(options);</span><br><span class="line">      <span class="keyword">if</span>(options.id) &#123; <span class="comment">//如果传过来是id则为分享页面进入的</span></span><br><span class="line">        <span class="built_in">this</span>.spu_id = options.id</span><br><span class="line">        <span class="built_in">this</span>.share.path = <span class="string">`/pages/index/goodsDetail?id=<span class="subst">$&#123;options.id&#125;</span>`</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.spu_id = options.spu_id;</span><br><span class="line">      <span class="built_in">this</span>.share.path = <span class="string">`/pages/index/goodsDetail?id=<span class="subst">$&#123;options.spu_id&#125;</span>`</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>uniapp</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>Python草料二维码等计数二维码刷访客量</title>
    <url>/python/</url>
    <content><![CDATA[<p>在生活中，很多时候被人邀请扫一扫二维码，刷一刷访客量。但是一个ip只能算作一个访问量，对此我们用Python来实现批量刷访客量。</p>
<p>Python版本3.6</p>
<p>首先上代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python  </span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib.parse  </span><br><span class="line"><span class="keyword">import</span> urllib.request  </span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 短网址还原 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">revertShortLink</span>(<span class="params">url</span>):</span></span><br><span class="line">	re = requests.head(url)</span><br><span class="line">	<span class="keyword">return</span> re.headers.get(<span class="string">&#x27;location&#x27;</span>)</span><br><span class="line"></span><br><span class="line">URL_1 = revertShortLink(<span class="string">&quot;your revertShortLink&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">global</span> url_path  </span><br><span class="line">url_path = [<span class="number">3</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verif_ip</span>(<span class="params">ip,port</span>):</span>    <span class="comment"># 验证ip有效性  </span></span><br><span class="line">	</span><br><span class="line">	test_url = URL_1</span><br><span class="line">	</span><br><span class="line">	browser = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line">	browser.get(URL_1)</span><br><span class="line">	browser.quit()</span><br><span class="line">	time.sleep(random.randint(<span class="number">1</span>,<span class="number">20</span>))  </span><br><span class="line"></span><br><span class="line">file = open(<span class="string">&quot;ip.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">counter = <span class="number">0</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:  </span><br><span class="line">	lines = file.readlines(<span class="number">100000</span>)  </span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> lines:  </span><br><span class="line">		<span class="keyword">break</span>  </span><br><span class="line">	<span class="keyword">for</span> data <span class="keyword">in</span> lines:</span><br><span class="line">		counter += <span class="number">1</span>  </span><br><span class="line">		print((data.split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]))</span><br><span class="line">		print(<span class="string">&quot;cishu:&quot;</span>,counter)  </span><br><span class="line">	</span><br><span class="line">	   </span><br><span class="line"></span><br><span class="line">	 </span><br><span class="line">		verif_ip(data.split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>],data.split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>全部代码我已经打包放在我的Github上面了，直接下载即可。<a href="https://github.com/Vanlee0129/caoliaoscan">下载地址</a></p>
<p>ip.txt文件就是用来存放代理ip的，相当于一个简陋的代理池，手动复制进去即可，我提供了一些，如果不够可以再自己去找一些。</p>
<p>ip可以在66ip等网站去提取，用多少提多少。以后再也不担心刷二维码访客量啦！</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>使用require.context导入多个模块</title>
    <url>/requireContext/</url>
    <content><![CDATA[<h2 id="使用契机"><a href="#使用契机" class="headerlink" title="使用契机"></a>使用契机</h2><p>将API接口文件分模块存放后需要导入统一的入口文件再统一导出，然后在<code>main.js</code>中引用。看着分门别类的接口文件很舒服，但是文件一多，导入统一入口文件<code>index.js</code>就显得很繁琐。效果如下:  </p>
<p><img src="https://ftp.bmp.ovh/imgs/2020/10/76da31964bce1579.png" alt="api文件列表"></p>
<p><img src="https://ftp.bmp.ovh/imgs/2020/10/44989b9516d6df61.png" alt="导入列表">  </p>
<p><img src="https://ftp.bmp.ovh/imgs/2020/10/e18f9f04cb0884cf.png" alt="导入列表"></p>
<p>说实话，这个看着越看越反人类。所以决定用更简洁的<code>require.context</code>来处理这个问题。  </p>
<h2 id="require-context"><a href="#require-context" class="headerlink" title="require.context"></a>require.context</h2><p><code>require.context</code>是一个<code>webpack</code>的<code>api</code>,通过执行<code>require.context函数</code>获取一个特定的上下文,主要用来实现自动化导入模块,在前端工程中,如果遇到从一个文件夹引入很多模块的情况,可以使用这个<code>api</code>,它会遍历文件夹中的指定文件,然后自动导入,使得不需要每次显式的调用<code>import</code>导入模块  </p>
<p><code>require.context函数</code>接受三个参数</p>
<ul>
<li><p><code>directory &#123;String&#125;</code> -读取文件的路径</p>
</li>
<li><p><code>useSubdirectories &#123;Boolean&#125;</code> -是否遍历文件的子目录</p>
</li>
<li><p><code>regExp &#123;RegExp&#125;</code> -匹配文件的正则</p>
</li>
</ul>
<p>webpack官网给出的例子是这样的:  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.context(<span class="string">&#x27;./test&#x27;</span>, <span class="literal">false</span>, <span class="regexp">/.test.js$/</span>)</span><br></pre></td></tr></table></figure>

<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>首先根据需要让<code>require.context</code>遍历<code>/src/api</code>目录。遍历的过程中肯定会把index.js也遍历进去，因为不想之后来处理遍历后的结果，所以先粗暴的用名称区分。  </p>
<p>我将以前的模块名.js改成为了模块名.api.js。  </p>
<p><img src="https://ftp.bmp.ovh/imgs/2020/10/f57afe8c22ddd303.png" alt="api文件列表"></p>
<p>接着开始编写一个导入函数来处理<code>require.context</code>返回的结果。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// importAllModule.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>批量导入API</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>context 上下文对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;RegExp&#125;</span> </span>reg 匹配规则</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Object&#125;</span> </span>对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">importAllModule</span>(<span class="params">context, reg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> map = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> tmp = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> context.keys()) &#123;</span><br><span class="line">        <span class="keyword">const</span> keyArr = key.split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        keyArr.shift()</span><br><span class="line">        map[keyArr.join(<span class="string">&#x27;.&#x27;</span>).replace(reg, <span class="string">&#x27;&#x27;</span>)] = context(key).default</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> map) &#123;</span><br><span class="line">        tmp = &#123;</span><br><span class="line">            ...tmp,</span><br><span class="line">            ...map[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> importAllModule </span><br></pre></td></tr></table></figure>
<p>接着在<code>index.js</code>中导入<code>importAllModule.js</code>并调用导入函数。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> importAllModule <span class="keyword">from</span> <span class="string">&#x27;../common/js/importAllModule&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> api = importAllModule(<span class="built_in">require</span>.context(<span class="string">&#x27;api&#x27;</span>, <span class="literal">true</span>, <span class="regexp">/\.api.js$/</span>), <span class="regexp">/\.api.js$/g</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> api</span><br></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>经过<code>require.context</code>的改造，大大解放了生产力。首先是index.js变得更加的简洁和可维护。其次，只要按格式编写API文件的文件名，就会被<code>require.context</code>遍历到并导入到<code>index.js</code>中。</p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>commonJS</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>JS生成二维码</title>
    <url>/qrcode/</url>
    <content><![CDATA[<h2 id="qrcode与qr-image"><a href="#qrcode与qr-image" class="headerlink" title="qrcode与qr-image"></a>qrcode与qr-image</h2><table>
<thead>
<tr>
<th>库名称</th>
<th>库大小</th>
<th>github start</th>
<th>文档地址</th>
</tr>
</thead>
<tbody><tr>
<td>qrcode</td>
<td>573.35 KiB</td>
<td>4.7k</td>
<td><a href="https://github.com/soldair/node-qrcode">https://github.com/soldair/node-qrcode</a></td>
</tr>
<tr>
<td>qr-image</td>
<td>10.67 KiB</td>
<td>917</td>
<td><a href="https://github.com/alexeyten/qr-image">https://github.com/alexeyten/qr-image</a></td>
</tr>
</tbody></table>
<h2 id="效果对比"><a href="#效果对比" class="headerlink" title="效果对比"></a>效果对比</h2><p><img src="https://www.hualigs.cn/image/6037038499fea.jpg" alt="效果"></p>
<h2 id="限制说明"><a href="#限制说明" class="headerlink" title="限制说明"></a>限制说明</h2><ul>
<li><code>qrcode</code>使用的url长度超过215可能报错  </li>
<li><code>qrcode</code>和<code>qr-image</code>url越长生成的二维码越模糊  </li>
</ul>
<h2 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h2><p><code>qrcode</code>使用示例  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> QRCode <span class="keyword">from</span> <span class="string">&#x27;qrcode&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// With promises</span></span><br><span class="line">QRCode.toDataURL(<span class="string">&#x27;I am a pony!&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(url) <span class="comment">//二维码url，base64形式</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// With async/await</span></span><br><span class="line"><span class="keyword">const</span> generateQR = <span class="keyword">async</span> text =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> QRCode.toDataURL(text))</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>qr-image</code>使用示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> qr = <span class="built_in">require</span>(<span class="string">&#x27;qr-image&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> qr_url = qr.imageSync(<span class="string">&#x27;I love QR!&#x27;</span>); <span class="comment">//qr_url为unit8Array，需要自己转为Base64</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>从包大小看，<code>qr-image</code>远小于<code>qrcode</code></li>
<li>从生成二维的清晰度看，<code>qrcode</code>更加清晰。结合线上的二维使用的地方，二维码最小尺寸为<code>48px</code>，<code>qr-image</code>生成的<code>48px</code>的二维码在低分屏上扫描有一定的困难。  </li>
<li>从易用性看，<code>qrcode</code>为ES Module的方式使用，支持<code>Promise</code>和<code>async/await</code>，更加符合现代前端的使用习惯。  </li>
<li>从长期使用看，<code>qr-image</code>作者已经停止维护，<code>qrcode</code>作者还在继续维护且使用人数更多。  </li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
