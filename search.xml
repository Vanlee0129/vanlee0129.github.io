<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>超好用的图片浏览器Irfanview</title>
    <url>/Irfanview/</url>
    <content><![CDATA[<hr>
<p>再也不怕图片加载卡了。</p>
<p>系统自带的图片浏览器和国产的图片浏览器不是卡就是广告非常多，看着就烦。</p>
<p>所以，今天和大家推荐一款超好用的图片浏览器Irfanview，安装包仅3.37M。</p>
<p>非常的精致小巧，开图片基本是秒开，不快你砍我好伐。</p>
<blockquote>
<p><a href="https://www.irfanview.com/main_download_engl.htm">官网下载地址</a> </p>
</blockquote>
<p>安装教程如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/9708361-4551655311d56e73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="057a1dfd746f63d3150c5b0caaff550.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9708361-94b83d114d54150c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="09d81ca29f65081146ebe778d691d7c.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9708361-2f04932a5140b62b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a3ee830de8dad48e10aead84e4b1c37.png"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/9708361-977e0000f6bb75ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="41bf980aef3cda64f5a3be62be31a35.png"></p>
<p>其余全部狂点下一步就行了  </p>
<p>我保证开图片再也不卡了</p>
]]></content>
      <categories>
        <category>实用工具</category>
      </categories>
  </entry>
  <entry>
    <title>const</title>
    <url>/const/</url>
    <content><![CDATA[<p>首先来看看 MDN 的描述：</p>
<blockquote>
<p>const 声明创建一个常量，其作用域可以是全局或本地声明的块。 与 var 变量不同，全局常量不会变为 window 对象的属性。需要一个常数的初始化器；也就是说，您必须在声明的同一语句中指定它的值（这是有道理的，因为以后不能更改）。<br />const 声明创建一个值的只读引用。但这并不意味着它所持有的值是不可变的，只是变量标识符不能重新分配。例如，在引用内容是对象的情况下，这意味着可以改变对象的内容（例如，其参数）。<br />关于“暂存死区”的所有讨论都适用于 let 和 const。一个常量不能和它所在作用域内的其他变量或函数拥有相同的名称。</p>
</blockquote>
<p>从 MDN 的描述中可以看出 const 如果用来声明一个值，那么这个值是不可变的，相当于常量。</p>
<p>如果声明一个对象，那么可以修改对象的内容，从某种意义上来说是可变的。</p>
<p>考虑如下例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span> <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b = &#123;</span><br><span class="line">    c: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b = &#123;<span class="attr">c</span>: <span class="number">2</span>&#125; <span class="comment">//报错</span></span><br><span class="line"></span><br><span class="line">b.c = <span class="number">2</span> <span class="comment">//不报错</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// &#123;c: 2&#125;</span></span><br></pre></td></tr></table></figure>

<p>当 a 初始化为 1 的时候，1 是值类型 Number，是直接存储在内存中的。而当 b 初始化为一个对象时，b 所储存的其实这个对象的内存地址，这个地址是一个值类型。</p>
<p>此时 b 是对这个对象的引用。</p>
<p>所以将{c: 2}赋值给 b 时其实是相当于把一个新的对象的内存地址赋值给 b 了，改变了 b 原本存储的值。</p>
<p>当直接通过字面量修改 c 的值为 2 时，其实修改的是这个对象本身的内容，并没有改变这个对象的内存地址，所以是不报错的。</p>
<blockquote>
<p>总结：const 声明的变量是不可变的，但是如果这个变量是一个引用类型，可以修改这个引用类型本身的内容。</p>
</blockquote>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker快速安装Jenkins</title>
    <url>/dockerInstallJenkins/</url>
    <content><![CDATA[<h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>CentOS Linux release 7.6.1810 (Core)<br>Docker version 19.03.12  </p>
<h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>我这里安装的版本是<code>jenkinsci/blueocean</code>，可以去这里获取你需要的版本: <a href="https://hub.docker.com/_/jenkins?tab=tags">dockerHub</a>，注意版本之间的区别。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker pull jenkinsci/blueocean</span></span><br></pre></td></tr></table></figure>

<h2 id="创建本地数据卷"><a href="#创建本地数据卷" class="headerlink" title="创建本地数据卷"></a>创建本地数据卷</h2><p>映射本地数据卷的路径为/data/jenkins_home/，想放别的地方可以自行修改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkdir -p /data/jenkins_home/</span></span><br></pre></td></tr></table></figure>
<p>需要修改下目录权限，因为当映射本地数据卷时，/data/jenkins_home/目录的拥有者为root用户，而容器中jenkins用户的 uid 为 1000。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> chown -R 1000:1000 /data/jenkins_home/</span></span><br></pre></td></tr></table></figure>
<h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker run -d --name jenkins -p 9021:8080 -p 50000:50000 -v /data/jenkins_home:/var/jenkins_home jenkins/jenkins:2.222.3-centos</span></span><br></pre></td></tr></table></figure>
<p><code>-d</code> 标识是让 docker 容器在后台运行<br><code>--name</code> 定义一个容器的名字，如果没有指定，那么会自动生成一个随机数字符串当做UUID<br><code>-p</code> 9021:8080 端口映射，不被占用的合法端口都可以使用，我用的9021<br><code>-p</code> 50000:50000 端口映射<br><code>-v</code> /data/jenkins_home:/var/jenkins_home 绑定一个数据卷，/data/jenkins_home是刚才创建的本地数据卷</p>
<h2 id="配置-Jenkins"><a href="#配置-Jenkins" class="headerlink" title="配置 Jenkins"></a>配置 Jenkins</h2><h3 id="打开-Jenkins"><a href="#打开-Jenkins" class="headerlink" title="打开 Jenkins"></a>打开 Jenkins</h3><p>通过浏览器访问 <code>http://xx.xx.xx.xx:9021/</code>（注意替换成你自己的IP和端口）进入初始页，如果 Jenkins 还没有启动完成，会显示如下内容<br><img src="https://ftp.bmp.ovh/imgs/2020/10/cd62632b22fa7dc1.png" alt="初始化界面"></p>
<h3 id="输入管理员密码"><a href="#输入管理员密码" class="headerlink" title="输入管理员密码"></a>输入管理员密码</h3><p><img src="https://ftp.bmp.ovh/imgs/2020/10/305ce3669e4731d4.png" alt="输入管理员密码"><br>这里要求输入初始的管理员密码，根据提示密码在/var/jenkins_home/secrets/initialAdminPassword这个文件中，注意这个路径是 Docker 容器中的，所以我们通过如下命令获取  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /data/jenkins_home/secrets/initialAdminPassword </span></span><br></pre></td></tr></table></figure>
<p>输入密码后，点击<code>继续</code>    </p>
<hr>
<p>到此Jenkins就安装完毕，安装插件时可以先换源再安装，不然速度会很慢 </p>
]]></content>
      <categories>
        <category>实用工具</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>深拷贝</title>
    <url>/deepCopy/</url>
    <content><![CDATA[<p>由于JS中的数据类型分为值类型和引用类型，所以对于引用类型来说变量储存的其实是地址而不是这个对象本身。考虑如下例子：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    b: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = a</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, c) <span class="comment">// &#123;b: 1&#125; &#123;b: 1&#125;</span></span><br><span class="line"></span><br><span class="line">a.b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// &#123;b: 2&#125;</span></span><br></pre></td></tr></table></figure>
<p>从上面例子可以看出a变化后c也跟着变了，显然这不是我们想要的结果。出现以上的原因是直接将a赋值给c是一种浅拷贝。实际上是将a所对应的地址赋值给了c。  </p>
<p>为了解决这个问题，我们需要深拷贝。对于以上例子我们可以采用以下办法：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> c = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a))  </span><br></pre></td></tr></table></figure>

<p>但是这个方法有以下局限性：  </p>
<ul>
<li><p>他无法实现对函数 、RegExp等特殊对象的克隆</p>
</li>
<li><p>会抛弃对象的constructor,所有的构造函数会指向Object</p>
</li>
<li><p>对象有循环引用,会报错  </p>
</li>
</ul>
<p>在生产环境我们一般使用第三方库成熟的方法，但是核心原理其实是一样的。  </p>
<p>现在们来实现一个简版的深拷贝：  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> deepCloneOne = <span class="function">(<span class="params">initalObj</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> initalObj !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> initalObj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> initalObj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> initalObj[key] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//对数组特殊处理</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(initalObj[key])) &#123;</span><br><span class="line">                <span class="comment">//用map方法返回新数组，将数组中的元素递归</span></span><br><span class="line">                obj[key] = initalObj[key].map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.deepCloneOne(item)</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//递归返回新对象</span></span><br><span class="line">                obj[key] = <span class="built_in">this</span>.deepCloneOne(initalObj[key])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> initalObj[key] === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">//返回新函数</span></span><br><span class="line">            obj[key] = initalObj[key].bind(obj)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//基本类型直接返回</span></span><br><span class="line">            obj[key] = initalObj[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span></span>&#125; obj </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCloneTwo</span>(<span class="params">obj = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//obj是null或者不是对象</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化返回结果</span></span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">        result = []</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="comment">//保证key不是原型的属性</span></span><br><span class="line">            <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">                <span class="comment">//递归调用</span></span><br><span class="line">                result[key] = deepCloneTwo(obj[key])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心思路就先判断这个对象是哪种对象，然后根据这种对象的特点去构造一个新的对象，用递归的方法将这个对象的所有属性都挨个赋给新对象。  </p>
<p>深拷贝产生的新对象和原来的对象没有一点关系，只是长得一样，但是是存储在一块新开辟的空间，两者之间不会互相影响。</p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6中的let</title>
    <url>/es6-let/</url>
    <content><![CDATA[<p>let是ES6定义的新关键词，用于声明变量，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>let声明的变量不能重复声明，例如： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span> </span><br><span class="line"><span class="keyword">let</span> a = <span class="number">2</span> <span class="comment">//Identifier &#x27;a&#x27; has already been declared</span></span><br></pre></td></tr></table></figure>
<p>let也可以不用初始化，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a)<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>let是块级作用域，可以解决for循环中变量泄露的问题，例如: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    arr.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(i)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    arr() <span class="comment">//打印10次10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面为什么输出10次10呢？因为为变量 i 在循环的每次迭代中都被共享了，意味着循环内创建的那些函数都拥有对于同一 变量的引用。在循环结束后，变量 i 的值会是 10 ，因此当 console.log(i) 被调用时， 每次都打印出 10 。  </p>
<p>现在用let改写这个例子： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    arr.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(i)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    arr() <span class="comment">//0-9</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>为什么let可以解决这个问题呢？因为在每次迭代中，let都会创建一个新的同名变量并对其进行初始化。在循环中 let 声明每次都创建了一个新的 i 变量，因此在循环内部创建的函数获得了各自的 i 副 本，而每个 i 副本的值都在每次循环迭代声明变量的时候被确定了。</p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>let</tag>
      </tags>
  </entry>
  <entry>
    <title>v-if失效时强制刷新</title>
    <url>/forceUpdate/</url>
    <content><![CDATA[<p><code>v-if</code>动态计算时，如果数据层级太深可能导致<code>render</code>函数没有自动刷新，所以需要手动刷新。此时可以调用<code>this.$forceUpdate()</code>强制刷新。</p>
<p>使用示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.couponList[index].isSelected = <span class="literal">true</span></span><br><span class="line"><span class="comment">//赋值后调用强制刷新</span></span><br><span class="line"><span class="built_in">this</span>.$forceUpdate()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>v-if</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的前端灰度发布方案</title>
    <url>/grayDeploy/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>灰度发布（又名金丝雀发布）是指在黑与白之间，能够平滑过渡的一种发布方式。在其上可以进行A/B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。  </p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>灰度发布的核心就是分流，一部分用户能看到，一部分用户看不到。所以主要实现的核心分流算法。在实现这个需求的时候，我想到了抽签。比如在1-100的数字中抽到1-30的用户进入beta版本，抽到31-100的用户进入stable版本。这样就相当于是30%的流量进入灰度版本。  </p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>首先实现产生1-100的整数的随机函数。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***************************************</span></span><br><span class="line"><span class="comment"> * 生成从minNum到maxNum的随机数。</span></span><br><span class="line"><span class="comment"> * 如果指定decimalNum个数，则生成指定小数位数的随机数</span></span><br><span class="line"><span class="comment"> * 如果不指定任何参数，则生成0-1之间的随机数。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@minNum</span>：[数据类型是Integer]生成的随机数的最小值（minNum和maxNum可以调换位置）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@maxNum</span>：[数据类型是Integer]生成的随机数的最大值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@decimalNum</span>：[数据类型是Integer]如果生成的是带有小数的随机数，则指定随机数的小数点后的位数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> ****************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomNum</span>(<span class="params">maxNum, minNum, decimalNum</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> max = <span class="number">0</span>,</span><br><span class="line">        min = <span class="number">0</span>;</span><br><span class="line">    minNum &lt;= maxNum ? ((min = minNum), (max = maxNum)) : ((min = maxNum), (max = minNum));</span><br><span class="line">    <span class="keyword">switch</span> (<span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * (max - min + <span class="number">1</span>) + min);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> (<span class="built_in">Math</span>.random() * (max - min) + min).toFixed(decimalNum);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Math</span>.random();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后实现灰度流量的判断  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>灰度显示</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>defaultLucky 灰度值，取值范围[0,1]</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Boolean&#125;</span> </span>ture/false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isShowGray</span>(<span class="params">defaultLucky</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!lucky) lucky = defaultLucky;</span><br><span class="line">    <span class="keyword">var</span> num = randomNum(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= <span class="built_in">Number</span>(<span class="number">100</span> * lucky) &amp;&amp; num &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，简单的灰度方案就做好了。在进入页面时先调用<code>isShowGray</code>函数判断进入哪个方案。这样就可以做到简单的用户分流。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>使用node加解密DES-CBC</title>
    <url>/node-des/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了保护请求内容不被抓包软件暴露出来，很多产品都采用了请求加密的方式。DES-CBC就是一种对称加密方式。在网上查资料时发现node的资料不多，所以研究之后记录一下使用node加解密DES-CBC。  </p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>首先是加密函数：  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>DES加密，以hex为例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>encodeTxt 待加密的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>key 秘钥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>iv 偏移量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">desEncode</span>(<span class="params">encodeTxt, key, iv</span>) </span>&#123;</span><br><span class="line">    key = key.length &gt;= <span class="number">8</span> ? key.slice(<span class="number">0</span>, <span class="number">8</span>) : key.concat(<span class="string">&#x27;0&#x27;</span>.repeat(<span class="number">8</span> - key.length))</span><br><span class="line">    iv = iv.length &gt;= <span class="number">8</span> ? iv.slice(<span class="number">0</span>, <span class="number">8</span>) : iv.concat(<span class="string">&#x27;0&#x27;</span>.repeat(<span class="number">8</span> - iv.length))</span><br><span class="line">    <span class="keyword">const</span> keyHex = Buffer.from(key)</span><br><span class="line">    <span class="keyword">const</span> ivHex = Buffer.from(iv)</span><br><span class="line">    <span class="keyword">const</span> encipher = crypto.createCipheriv(<span class="string">&#x27;des-cbc&#x27;</span>, keyHex, ivHex)</span><br><span class="line">    <span class="comment">//编码方式除了可以使用hex还可以使用base64。</span></span><br><span class="line">    <span class="keyword">let</span> encode = encipher.update(encodeTxt, <span class="string">&#x27;utf8&#x27;</span>, <span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">    encode += encipher.final(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> encode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解密函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>DES解密，要和加密方式对应起来</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>decodeTxt 待解密的字符串</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>key 秘钥</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;String&#125;</span> </span>iv 偏移量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">desDecode</span>(<span class="params">decodeTxt, key, iv</span>) </span>&#123;</span><br><span class="line">    key = key.length &gt;= <span class="number">8</span> ? key.slice(<span class="number">0</span>, <span class="number">8</span>) : key.concat(<span class="string">&#x27;0&#x27;</span>.repeat(<span class="number">8</span> - key.length))</span><br><span class="line">    iv = iv.length &gt;= <span class="number">8</span> ? iv.slice(<span class="number">0</span>, <span class="number">8</span>) : iv.concat(<span class="string">&#x27;0&#x27;</span>.repeat(<span class="number">8</span> - iv.length))</span><br><span class="line">    <span class="keyword">const</span> keyHex = Buffer.from(key)</span><br><span class="line">    <span class="keyword">const</span> ivHex = Buffer.from(iv)</span><br><span class="line">    <span class="keyword">const</span> decipher = crypto.createDecipheriv(<span class="string">&#x27;des-cbc&#x27;</span>, keyHex, ivHex)</span><br><span class="line">    <span class="keyword">let</span> decode = decipher.update(decodeTxt, <span class="string">&#x27;hex&#x27;</span>, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    decode += decipher.final(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> decodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在使用时要特别注意加密和解密的编码方式要对应起来，如果没有对应起来就会报错或者得不到结果。</p>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>des-cbc</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>npm发包记录</title>
    <url>/npm/</url>
    <content><![CDATA[<h2 id="注册-NPM-账号"><a href="#注册-NPM-账号" class="headerlink" title="注册 NPM 账号"></a>注册 NPM 账号</h2><p>首先去 npm 官网注册账号，注册地址<a href="https://www.npmjs.com/">https://www.npmjs.com/</a>。然后验证邮箱即注册完成。</p>
<h2 id="准备要发布的包"><a href="#准备要发布的包" class="headerlink" title="准备要发布的包"></a>准备要发布的包</h2><p>准备发布的包在开发好后要注意 package.json 中的如下信息：</p>
<ul>
<li>name 包名</li>
<li>version  版本号，更新版本时需要修改版本号</li>
<li>dependencies  包依赖</li>
</ul>
<h2 id="相关目录规范"><a href="#相关目录规范" class="headerlink" title="相关目录规范"></a>相关目录规范</h2><ul>
<li><code>src</code>：源码源文件。</li>
<li><code>lib</code>：依赖文件（没通过 npm，直接下载源码的那种）。</li>
<li><code>node_modules</code>：npm 依赖文件。</li>
<li><code>bin</code>：二进制可执行文件。</li>
<li><code>tests</code>：单元测试或集成测试文件。</li>
<li><code>docs</code>：文档、开发手册。</li>
<li><code>examples</code>：示例代码或项目。</li>
<li><code>build</code>：构建时所需文件。</li>
<li><code>dist</code>：打包后的输出目录。</li>
</ul>
<h2 id="查看-npm-源"><a href="#查看-npm-源" class="headerlink" title="查看 npm 源"></a>查看 npm 源</h2><p>一定要确保 npm 源为官方源<a href="https://registry.npmjs.org/">https://registry.npmjs.org</a>。如果要查看自己当前的源则使用：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm config get registry</span><br></pre></td></tr></table></figure>

<p>如果是非官方源则使用如下命令调整：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmjs.org</span><br></pre></td></tr></table></figure>

<h2 id="开始发包"><a href="#开始发包" class="headerlink" title="开始发包"></a>开始发包</h2><p>首先在终端中登录 npm，使用命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm adduse</span><br></pre></td></tr></table></figure>

<p>登录完成后发布我们需要发布的包：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm publish --access public</span><br></pre></td></tr></table></figure>

<p>发布成功后可以看到如下信息：</p>
<p><a href="https://imgchr.com/i/rH5uy6"><img src="https://s3.ax1x.com/2020/12/29/rH5uy6.png" alt="发布成功"></a></p>
<h2 id="查看发布的包"><a href="#查看发布的包" class="headerlink" title="查看发布的包"></a>查看发布的包</h2><p>发包成后可以在<a href="https://www.npmjs.com/">https://www.npmjs.com/</a>中搜索刚刚发布的包，结果如下：</p>
<p><a href="https://imgchr.com/i/rH5QeO"><img src="https://s3.ax1x.com/2020/12/29/rH5QeO.png" alt="查看发布"></a></p>
<h2 id="使用发布的包"><a href="#使用发布的包" class="headerlink" title="使用发布的包"></a>使用发布的包</h2><p>首先在 Demo 中安装刚刚发布的包：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm i node-des-cbc</span><br></pre></td></tr></table></figure>

<p>然后验证包是否可用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> des = <span class="built_in">require</span>(<span class="string">&quot;node-des-cbc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(des);</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><a href="https://imgchr.com/i/rH5GYd"><img src="https://s3.ax1x.com/2020/12/29/rH5GYd.png" alt="发布结果"></a></p>
<p>发包所用代码地址： <a href="https://github.com/Vanlee0129/node-des-cbc">https://github.com/Vanlee0129/node-des-cbc</a></p>
<p>npm 官网地址: <a href="https://www.npmjs.com/package/node-des-cbc">https://www.npmjs.com/package/node-des-cbc</a></p>
]]></content>
      <categories>
        <category>开发相关</category>
      </categories>
      <tags>
        <tag>npm</tag>
        <tag>发包</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP/1HTTP/2HTTP/3</title>
    <url>/http/</url>
    <content><![CDATA[<h2 id="HTTP1-1-与-HTTP2"><a href="#HTTP1-1-与-HTTP2" class="headerlink" title="HTTP1.1 与 HTTP2"></a>HTTP1.1 与 HTTP2</h2><h3 id="HTTP1-1-的缺陷"><a href="#HTTP1-1-的缺陷" class="headerlink" title="HTTP1.1 的缺陷"></a>HTTP1.1 的缺陷</h3><p>高延迟 — 队头阻塞(Head-Of-Line Blocking)<br>无状态特性 — 阻碍交互<br>明文传输 — 不安全性<br>不支持服务端推送<br>队头阻塞<br>队头阻塞是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。</p>
<h3 id="针对队头阻塞"><a href="#针对队头阻塞" class="headerlink" title="针对队头阻塞"></a>针对队头阻塞</h3><ol>
<li><p>将同一页面的资源分散到不同域名下，提升连接上限。虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。</p>
</li>
<li><p>减少请求数量</p>
</li>
<li><p>内联一些资源：css、base64 图片等</p>
</li>
<li><p>合并小文件减少资源数</p>
</li>
</ol>
<h3 id="无状态特性"><a href="#无状态特性" class="headerlink" title="无状态特性"></a>无状态特性</h3><p>无状态是指协议对于连接状态没有记忆能力。纯净的 HTTP 是没有 cookie 等机制的，每一个连接都是一个新的连接。上一次请求验证了用户名密码，而下一次请求服务器并不知道它与上一条请求有何关联，换句话说就是掉登录态。</p>
<h3 id="不安全性"><a href="#不安全性" class="headerlink" title="不安全性"></a>不安全性</h3><p>传输内容没有加密，中途可能被篡改和劫持。</p>
<h3 id="SPDY-协议"><a href="#SPDY-协议" class="headerlink" title="SPDY 协议"></a>SPDY 协议</h3><p>SPDY 是由 google 推行的改进版本的 HTTP1.1 （那时候还没有 HTTP2）。</p>
<p><a href="https://imgtu.com/i/6BZO8x"><img src="https://s3.ax1x.com/2021/03/14/6BZO8x.jpg" alt="6BZO8x.jpg"></a></p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>多路复用 — 解决队头阻塞</li>
<li>头部压缩 — 解决巨大的 HTTP 头部</li>
<li>请求优先级 — 先获取重要数据</li>
<li>服务端推送 — 填补空缺</li>
<li>提高安全性</li>
<li>多路复用<br>SPDY 允许在一个连接上无限制并发流。因为请求在一个通道上，TCP 效率更高（参考 TCP 拥塞控制 中的慢启动）。更少的网络连接，发出更密集的包。</li>
</ul>
<h3 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h3><p>使用专门的 HPACK 算法，每次请求和响应只发送差异头部，一般可以达到 50%~90% 的高压缩率。</p>
<h3 id="请求优先级"><a href="#请求优先级" class="headerlink" title="请求优先级"></a>请求优先级</h3><p>虽然无限的并发流解决了队头阻塞的问题，但如果带宽受限，客户端可能会因防止堵塞通道而阻止请求。在网络通道被非关键资源堵塞时，高优先级的请求会被优先处理。</p>
<h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h3><p>服务端推送（ServerPush），可以让服务端主动把资源文件推送给客户端。当然客户端也有权利选择是否接收。</p>
<h3 id="提高安全性"><a href="#提高安全性" class="headerlink" title="提高安全性"></a>提高安全性</h3><p>支持使用 HTTPS 进行加密传输。</p>
<h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><p>HTTP2 基于 SPDY，专注于性能，最大的一个目标是在用户和网站间只用一个连接。</p>
<h3 id="新增特性"><a href="#新增特性" class="headerlink" title="新增特性"></a>新增特性</h3><ul>
<li>二进制分帧 - HTTP2 性能增强的核心</li>
<li>多路复用 - 解决串行的文件传输和连接数过多</li>
</ul>
<h3 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h3><p>首先，HTTP2 没有改变 HTTP1 的语义，只是在应用层使用二进制分帧方式传输。因此，也引入了新的通信单位：帧、消息、流。</p>
<p>分帧有什么好处？服务器单位时间接收到的请求数变多，可以提高并发数。最重要的是，为多路复用提供了底层支持。</p>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>一个域名对应一个连接，一个流代表了一个完整的请求-响应过程。帧是最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。多路复用，就是在一个 TCP 连接中可以存在多个流。演示</p>
<p><a href="https://imgtu.com/i/6Be9VH"><img src="https://s3.ax1x.com/2021/03/14/6Be9VH.jpg" alt="6Be9VH.jpg"></a></p>
<h3 id="HTTP2-的缺陷"><a href="#HTTP2-的缺陷" class="headerlink" title="HTTP2 的缺陷"></a>HTTP2 的缺陷</h3><ul>
<li>TCP 以及 TCP+TLS 建立连接的延时</li>
<li>TCP 的队头阻塞并没有彻底解决</li>
<li>多路复用导致服务器压力上升</li>
<li>多路复用容易 Timeout</li>
</ul>
<h3 id="建连延时"><a href="#建连延时" class="headerlink" title="建连延时"></a>建连延时</h3><p>TCP 连接需要和服务器进行三次握手，即消耗完 1.5 个 RTT 之后才能进行数据传输。</p>
<p>TLS 连接有两个版本—— TLS1.2 和 TLS1.3，每个版本建立连接所花的时间不同，大致需要 1~2 个 RTT。</p>
<h3 id="RTT（Round-Trip-Time）"><a href="#RTT（Round-Trip-Time）" class="headerlink" title="RTT（Round-Trip Time）"></a>RTT（Round-Trip Time）</h3><p>往返时延。表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后便立即发送确认），总共经历的时延。</p>
<h3 id="队头阻塞没有彻底解决"><a href="#队头阻塞没有彻底解决" class="headerlink" title="队头阻塞没有彻底解决"></a>队头阻塞没有彻底解决</h3><p>TCP 为了保证可靠传输，有一个“超时重传”机制，丢失的包必须等待重传确认。HTTP2 出现丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。</p>
<p><a href="https://imgtu.com/i/6BZxKO"><img src="https://s3.ax1x.com/2021/03/14/6BZxKO.jpg" alt="6BZxKO.jpg"></a></p>
<p>RTO：英文全称是 Retransmission TimeOut，即重传超时时间； RTO 是一个动态值，会根据网络的改变而改变。RTO 是根据给定连接的往返时间 RTT 计算出来的。 接收方返回的 ack 是希望收到的下一组包的序列号。</p>
<h3 id="多路复用导致服务器压力上升"><a href="#多路复用导致服务器压力上升" class="headerlink" title="多路复用导致服务器压力上升"></a>多路复用导致服务器压力上升</h3><p>多路复用没有限制同时请求数。请求的平均数量与往常相同，但实际会有许多请求的短暂爆发，导致瞬时 QPS 暴增。</p>
<h3 id="多路复用容易-Timeout"><a href="#多路复用容易-Timeout" class="headerlink" title="多路复用容易 Timeout"></a>多路复用容易 Timeout</h3><p>大批量的请求同时发送，由于 HTTP2 连接内存在多个并行的流，而网络带宽和服务器资源有限，每个流的资源会被稀释，虽然它们开始时间相差更短，但却都可能超时。</p>
<p>即使是使用 Nginx 这样的负载均衡器，想正确进行节流也可能很棘手。 其次，就算你向应用程序引入或调整排队机制，但一次能处理的连接也是有限的。如果对请求进行排队，还要注意在响应超时后丢弃请求，以避免浪费不必要的资源。引用</p>
<h2 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Google<br>在推 SPDY 的时候就已经意识到了这些问题，于是就另起炉灶搞了一个基于 UDP 协议的 QUIC 协议。而这个就是 HTTP3。它真正“完美”地解决了“队头阻塞”问题。</p>
<p><a href="https://imgtu.com/i/6BeCad"><img src="https://s3.ax1x.com/2021/03/14/6BeCad.jpg" alt="6BeCad.jpg"></a></p>
<h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><p>改进的拥塞控制、可靠传输<br>快速握手<br>集成了 TLS 1.3 加密<br>多路复用<br>连接迁移<br>改进的拥塞控制、可靠传输<br>从拥塞算法和可靠传输本身来看，QUIC 只是按照 TCP 协议重新实现了一遍，那么 QUIC 协议到底改进在哪些方面呢？主要有如下几点：</p>
<h3 id="可插拔-—-应用程序层面就能实现不同的拥塞控制算法"><a href="#可插拔-—-应用程序层面就能实现不同的拥塞控制算法" class="headerlink" title="可插拔 — 应用程序层面就能实现不同的拥塞控制算法"></a>可插拔 — 应用程序层面就能实现不同的拥塞控制算法</h3><p>一个应用程序的不同连接也能支持配置不同的拥塞控制。 应用程序不需要停机和升级就能实现拥塞控制的变更，可以针对不同业务，不同网络制式，甚至不同的 RTT，使用不同的拥塞控制算法。</p>
<p>关于应用层的可插拔拥塞控制模拟，可以对 socket 上的流为对象进行实验。</p>
<h3 id="单调递增的-Packet-Number-—-使用-Packet-Number-代替了-TCP-的-seq"><a href="#单调递增的-Packet-Number-—-使用-Packet-Number-代替了-TCP-的-seq" class="headerlink" title="单调递增的 Packet Number — 使用 Packet Number 代替了 TCP 的 seq"></a>单调递增的 Packet Number — 使用 Packet Number 代替了 TCP 的 seq</h3><p>每个 Packet Number 都严格递增，也就是说就算 Packet N 丢失了，重传的 Packet<br>N 的 Packet<br>Number 已经不是 N，而是一个比 N 大的值。而 TCP 重传策略存在二义性，比如客户端发送了一个请求，一个 RTO 后发起重传，而实际上服务器收到了第一次请求，并且响应已经在路上了，当客户端收到响应后，得出的 RTT 将会比真实 RTT 要小。当 Packet N 唯一之后，就可以计算出正确的 RTT。</p>
<h3 id="不允许-Reneging-—-一个-Packet-只要被-Ack，就认为它一定被正确接收"><a href="#不允许-Reneging-—-一个-Packet-只要被-Ack，就认为它一定被正确接收" class="headerlink" title="不允许 Reneging — 一个 Packet 只要被 Ack，就认为它一定被正确接收"></a>不允许 Reneging — 一个 Packet 只要被 Ack，就认为它一定被正确接收</h3><p>Reneging 的意思是，接收方有权把已经报给发送端 SACK（Selective Acknowledgment） 里的数据给丢了（如接收窗口不够而丢弃乱序的包）。</p>
<p>QUIC 中的 ACK 包含了与 TCP 中 SACK 等价的信息，但 QUIC 不允许任何（包括被确认接受的）数据包被丢弃。这样不仅可以简化发送端与接收端的实现难度，还可以减少发送端的内存压力。</p>
<h3 id="前向纠错（FEC）"><a href="#前向纠错（FEC）" class="headerlink" title="前向纠错（FEC）"></a>前向纠错（FEC）</h3><p>早期的 QUIC 版本存在一个丢包恢复机制，但后来由于增加带宽消耗和效果一般而废弃。FEC 中，QUIC 数据帧的数据混合原始数据和冗余数据，来确保无论到达接收端的 n 次传输内容是什么，接收端都能够恢复所有 n 个原始数据包。FEC 的实质就是异或。示意图：</p>
<p><a href="https://imgtu.com/i/6BZzrD"><img src="https://s3.ax1x.com/2021/03/14/6BZzrD.jpg" alt="6BZzrD.jpg"></a></p>
<h3 id="更多的-Ack-块和增加-Ack-Delay-时间"><a href="#更多的-Ack-块和增加-Ack-Delay-时间" class="headerlink" title="更多的 Ack 块和增加 Ack Delay 时间"></a>更多的 Ack 块和增加 Ack Delay 时间</h3><p>QUIC 可以同时提供 256 个 Ack Block，因此在重排序时，QUIC 相对于 TCP（使用 SACK）更有弹性，这也使得在重排序或丢失出现时，QUIC 可以在网络上保留更多的在途字节。在丢包率比较高的网络下，可以提升网络的恢复速度，减少重传量。</p>
<p>TCP 的 Timestamp 选项存在一个问题：发送方在发送报文时设置发送时间戳，接收方在确认该报文段时把时间戳字段值复制到确认报文时间戳，但是没有计算接收端接收到包到发送 Ack 的时间。这个时间可以简称为 Ack Delay，会导致 RTT 计算误差。现在就是把这个东西加进去计算 RTT 了。</p>
<h3 id="基于-stream-和-connection-级别的流量控制"><a href="#基于-stream-和-connection-级别的流量控制" class="headerlink" title="基于 stream 和 connection 级别的流量控制"></a>基于 stream 和 connection 级别的流量控制</h3><p>为什么需要两类流量控制呢？主要是因为 QUIC 支持多路复用。 Stream 可以认为就是一条 HTTP 请求。 Connection 可以类比一条 TCP 连接。多路复用意味着在一条 Connetion 上会同时存在多条 Stream。</p>
<p>QUIC 接收者会通告每个流中最多想要接收到的数据的绝对字节偏移。随着数据在特定流中的发送，接收和传送，接收者发送 WINDOW_UPDATE 帧，该帧增加该流的通告偏移量限制，允许对端在该流上发送更多的数据。</p>
<p>除了每个流的流控制外，QUIC 还实现连接级的流控制，以限制 QUIC 接收者愿意为连接分配的总缓冲区。连接的流控制工作方式与流的流控制一样，但传送的字节和最大的接收偏移是所有流的总和。</p>
<p>最重要的是，我们可以在内存不足或者上游处理性能出现问题时，通过流量控制来限制传输速率，保障服务可用性。</p>
<p><a href="https://imgtu.com/i/6BeSqe"><img src="https://s3.ax1x.com/2021/03/14/6BeSqe.jpg" alt="6BeSqe.jpg"></a></p>
<h3 id="快速握手"><a href="#快速握手" class="headerlink" title="快速握手"></a>快速握手</h3><p>由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现 0-RTT 或者 1-RTT 来建立连接，可以大大提升首次打开页面的速度。</p>
<p>集成了 TLS 1.3 加密<br>TLS 1.3 支持 3 种基本密钥交换模式：</p>
<p>(EC)DHE (基于有限域或椭圆曲线的 Diffie-Hellman)<br>PSK - only<br>PSK with (EC)DHE<br>在完全握手情况下，需要 1-RTT 建立连接。 TLS1.3 恢复会话可以直接发送加密后的应用数据，不需要额外的 TLS 握手，也就是 0-RTT。</p>
<p>TLS 1.3 0-RTT 简单原理示意（基于 DHE）：</p>
<p><a href="https://imgtu.com/i/6BePIA"><img src="https://s3.ax1x.com/2021/03/14/6BePIA.jpg" alt="6BePIA.jpg"></a></p>
<p>但是 TLS1.3 也并不完美。TLS 1.3 的 0-RTT 无法保证前向安全性(Forward secrecy)。简单讲就是，如果当攻击者通过某种手段获取到了 Session Ticket Key，那么该攻击者可以解密以前的加密数据。</p>
<p>要缓解该问题可以通过设置使得与 Session Ticket Key 相关的 DH 静态参数在短时间内过期（一般几个小时）。  </p>
<h3 id="多路复用-1"><a href="#多路复用-1" class="headerlink" title="多路复用"></a>多路复用</h3><p>QUIC 是为多路复用从头设计的，携带个别流的的数据的包丢失时，通常只影响该流。QUIC 连接上的多个 stream 之间并没有依赖，也不会有底层协议限制。假如 stream2 丢了一个包，也只会影响 stream2 的处理。</p>
<h3 id="连接迁移"><a href="#连接迁移" class="headerlink" title="连接迁移"></a>连接迁移</h3><p>TCP 是按照 4 要素（客户端 IP、端口, 服务器 IP、端口）确定一个连接的。而 QUIC 则是让客户端生成一个 Connection ID （64 位）来区别不同连接。只要 Connection ID 不变，连接就不需要重新建立，即便是客户端的网络发生变化。由于迁移客户端继续使用相同的会话密钥来加密和解密数据包，QUIC 还提供了迁移客户端的自动加密验证。</p>
<h2 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h2><h3 id="NAT-问题"><a href="#NAT-问题" class="headerlink" title="NAT 问题"></a>NAT 问题</h3><h4 id="NAT-概念"><a href="#NAT-概念" class="headerlink" title="NAT 概念"></a>NAT 概念</h4><p>为了解决 IP 地址不足的问题，NAT 给一个局域网络只分配一个 IP 地址，这个网络内的主机，则分配私有地址，这些私有地址对外是不可见的，他们对外的通信都要借助那个唯一分配的 IP 地址。所有离开本地网络去往 Internet 的数据报的源 IP 地址需替换为相同的 NAT，区别仅在于端口号不同。</p>
<p><a href="https://imgtu.com/i/6BZX26"><img src="https://s3.ax1x.com/2021/03/14/6BZX26.jpg" alt="6BZX26.jpg"></a></p>
<h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>TCP 和 UDP 的报文头部不同导致 NAT 问题的出现。</p>
<p>NAT 设备的端口记忆问题<br>对于基于 TCP 的 HTTP、HTTPS 传输，NAT 设备可以根据 TCP 报文头的 SYN/FIN 状态位，知道通信什么时候开始，什么时候结束，对应记忆 NAT 映射的开始和结束。</p>
<p>但是基于 UDP 传输的 HTTP3 ，不存在 SYN/FIN 状态位。NAT 设备的记忆如果短于用户会话时间，则用户会话会中断。NAT 设备的记忆时间如果长于用户会话时间，则意味着 NAT 设备的端口资源会被白白占用。</p>
<p>最直接的解决方案是，在 QUIC 的头部模仿 TCP 的 SYN/FIN 状态，让沿途的 NAT 设备知道会话什么时候开始、什么时候结束。但这需要升级全球所有的 NAT 设备的软件。</p>
<p>另外一个可行的方案是，让 QUIC 周期性地发送 Keepalive 消息，刷新 NAT 设备的记忆，避免 NAT 设备自动释放。</p>
<h4 id="NAT-设备禁用-UDP"><a href="#NAT-设备禁用-UDP" class="headerlink" title="NAT 设备禁用 UDP"></a>NAT 设备禁用 UDP</h4><p>在一些 NAT 网络环境下（如某些校园网），UDP 协议会被路由器等中间网络设备禁止，这时客户端会直接降级，选择 HTTPS 等备选通道，保证正常业务请求。</p>
<h3 id="NGINX-负载均衡问题"><a href="#NGINX-负载均衡问题" class="headerlink" title="NGINX 负载均衡问题"></a>NGINX 负载均衡问题</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>QUIC 客户端存在网络制式切换，就算是同一个移动机房，可能第一次业务请求时会落到 A 这台服务器，后续再次连接，就会落到 B 实例上，重复走 1-RTT 的完整握手流程。</p>
<h4 id="全局握手缓存"><a href="#全局握手缓存" class="headerlink" title="全局握手缓存"></a>全局握手缓存</h4><p>为所有 QUIC 服务器实例建立一个全局握手缓存。当用户网络发生切换时，下一次的业务请求无论是落到哪一个机房或哪一台实例上，握手建连都会是 0-RTT。</p>
<p>历代 HTTP 速度测试</p>
<p><a href="https://imgtu.com/i/6BZjxK"><img src="https://s3.ax1x.com/2021/03/14/6BZjxK.jpg" alt="6BZjxK.jpg"></a></p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>从古至今实时数据传输（音频、视频、游戏等）都面临卡顿、延迟等问题，而 QUIC 基于 UDP 的架构和改进的重传等特性，能够有效的提升用户体验。目前<br>B 站 也已经接入 QUIC。</p>
<p>如果想要自己体验 QUIC，可以使用 Libquic、Caddy 等。另外 github 上面也有 C++版本的 QUIC 实现，利用 Nodejs 的 C++ 模块，前端工程师也可以快速实现一个 node-quic。</p>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Python草料二维码等计数二维码刷访客量</title>
    <url>/python/</url>
    <content><![CDATA[<p>在生活中，很多时候被人邀请扫一扫二维码，刷一刷访客量。但是一个ip只能算作一个访问量，对此我们用Python来实现批量刷访客量。</p>
<p>Python版本3.6</p>
<p>首先上代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python  </span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib.parse  </span><br><span class="line"><span class="keyword">import</span> urllib.request  </span><br><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 短网址还原 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">revertShortLink</span>(<span class="params">url</span>):</span></span><br><span class="line">	re = requests.head(url)</span><br><span class="line">	<span class="keyword">return</span> re.headers.get(<span class="string">&#x27;location&#x27;</span>)</span><br><span class="line"></span><br><span class="line">URL_1 = revertShortLink(<span class="string">&quot;your revertShortLink&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">global</span> url_path  </span><br><span class="line">url_path = [<span class="number">3</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verif_ip</span>(<span class="params">ip,port</span>):</span>    <span class="comment"># 验证ip有效性  </span></span><br><span class="line">	</span><br><span class="line">	test_url = URL_1</span><br><span class="line">	</span><br><span class="line">	browser = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line">	browser.get(URL_1)</span><br><span class="line">	browser.quit()</span><br><span class="line">	time.sleep(random.randint(<span class="number">1</span>,<span class="number">20</span>))  </span><br><span class="line"></span><br><span class="line">file = open(<span class="string">&quot;ip.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">counter = <span class="number">0</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:  </span><br><span class="line">	lines = file.readlines(<span class="number">100000</span>)  </span><br><span class="line">	<span class="keyword">if</span> <span class="keyword">not</span> lines:  </span><br><span class="line">		<span class="keyword">break</span>  </span><br><span class="line">	<span class="keyword">for</span> data <span class="keyword">in</span> lines:</span><br><span class="line">		counter += <span class="number">1</span>  </span><br><span class="line">		print((data.split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]))</span><br><span class="line">		print(<span class="string">&quot;cishu:&quot;</span>,counter)  </span><br><span class="line">	</span><br><span class="line">	   </span><br><span class="line"></span><br><span class="line">	 </span><br><span class="line">		verif_ip(data.split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>],data.split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>
<p>全部代码我已经打包放在我的Github上面了，直接下载即可。<a href="https://github.com/Vanlee0129/caoliaoscan">下载地址</a></p>
<p>ip.txt文件就是用来存放代理ip的，相当于一个简陋的代理池，手动复制进去即可，我提供了一些，如果不够可以再自己去找一些。</p>
<p>ip可以在66ip等网站去提取，用多少提多少。以后再也不担心刷二维码访客量啦！</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序分享API踩坑</title>
    <url>/onShareAppMessage/</url>
    <content><![CDATA[<p>微信小程序分享API <code>onShareAppMessage</code> 带的参数只能叫<code>id</code>，不能叫其他的，不然拿不到。  </p>
<p>使用时可以在单页面使用，也可以使用全局混入，一般来说我们都使用全局混入的方式去做。  </p>
<p>注意，这个函数是一个页面钩子函数，需要与onLoad等函数同级。  </p>
<p>使用示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//share.mixin.js</span></span><br><span class="line"><span class="keyword">export</span>  <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            share: &#123;</span><br><span class="line">                title: <span class="string">&#x27;你的标题&#x27;</span>,</span><br><span class="line">                path: <span class="string">&#x27;/pages/index/index&#x27;</span>,</span><br><span class="line">                imageUrl: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                desc: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    onShareAppMessage(res) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="comment">//标题</span></span><br><span class="line">            title: <span class="built_in">this</span>.share.title,</span><br><span class="line">            <span class="comment">//页面路径</span></span><br><span class="line">            path: <span class="built_in">this</span>.share.path,</span><br><span class="line">            <span class="comment">//分享后显示的图片的地址，默认为当前页面的截图</span></span><br><span class="line">            imageUrl: <span class="built_in">this</span>.share.imageUrl,</span><br><span class="line">            <span class="comment">//描述</span></span><br><span class="line">            desc: <span class="built_in">this</span>.share.desc,</span><br><span class="line">            <span class="comment">//内容</span></span><br><span class="line">            content: <span class="built_in">this</span>.share.content,</span><br><span class="line">            success(res) &#123;</span><br><span class="line">                uni.showToast(&#123;</span><br><span class="line">                    title: <span class="string">&#x27;分享成功&#x27;</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">            fail(res) &#123;</span><br><span class="line">                uni.showToast(&#123;</span><br><span class="line">                    title: <span class="string">&#x27;分享失败&#x27;</span>,</span><br><span class="line">                    icon: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在页面中使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//example.vue</span></span><br><span class="line"><span class="keyword">async</span> onLoad(options) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(options);</span><br><span class="line">      <span class="keyword">if</span>(options.id) &#123; <span class="comment">//如果传过来是id则为分享页面进入的</span></span><br><span class="line">        <span class="built_in">this</span>.spu_id = options.id</span><br><span class="line">        <span class="built_in">this</span>.share.path = <span class="string">`/pages/index/goodsDetail?id=<span class="subst">$&#123;options.id&#125;</span>`</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.spu_id = options.spu_id;</span><br><span class="line">      <span class="built_in">this</span>.share.path = <span class="string">`/pages/index/goodsDetail?id=<span class="subst">$&#123;options.spu_id&#125;</span>`</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>uniapp</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>JS生成二维码</title>
    <url>/qrcode/</url>
    <content><![CDATA[<h2 id="qrcode与qr-image"><a href="#qrcode与qr-image" class="headerlink" title="qrcode与qr-image"></a>qrcode与qr-image</h2><table>
<thead>
<tr>
<th>库名称</th>
<th>库大小</th>
<th>github start</th>
<th>文档地址</th>
</tr>
</thead>
<tbody><tr>
<td>qrcode</td>
<td>573.35 KiB</td>
<td>4.7k</td>
<td><a href="https://github.com/soldair/node-qrcode">https://github.com/soldair/node-qrcode</a></td>
</tr>
<tr>
<td>qr-image</td>
<td>10.67 KiB</td>
<td>917</td>
<td><a href="https://github.com/alexeyten/qr-image">https://github.com/alexeyten/qr-image</a></td>
</tr>
</tbody></table>
<h2 id="效果对比"><a href="#效果对比" class="headerlink" title="效果对比"></a>效果对比</h2><p><img src="https://www.hualigs.cn/image/6037038499fea.jpg" alt="效果"></p>
<h2 id="限制说明"><a href="#限制说明" class="headerlink" title="限制说明"></a>限制说明</h2><ul>
<li><code>qrcode</code>使用的url长度超过215可能报错  </li>
<li><code>qrcode</code>和<code>qr-image</code>url越长生成的二维码越模糊  </li>
</ul>
<h2 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h2><p><code>qrcode</code>使用示例  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> QRCode <span class="keyword">from</span> <span class="string">&#x27;qrcode&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// With promises</span></span><br><span class="line">QRCode.toDataURL(<span class="string">&#x27;I am a pony!&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(url) <span class="comment">//二维码url，base64形式</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// With async/await</span></span><br><span class="line"><span class="keyword">const</span> generateQR = <span class="keyword">async</span> text =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">await</span> QRCode.toDataURL(text))</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>qr-image</code>使用示例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> qr = <span class="built_in">require</span>(<span class="string">&#x27;qr-image&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> qr_url = qr.imageSync(<span class="string">&#x27;I love QR!&#x27;</span>); <span class="comment">//qr_url为unit8Array，需要自己转为Base64</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>从包大小看，<code>qr-image</code>远小于<code>qrcode</code></li>
<li>从生成二维的清晰度看，<code>qrcode</code>更加清晰。结合线上的二维使用的地方，二维码最小尺寸为<code>48px</code>，<code>qr-image</code>生成的<code>48px</code>的二维码在低分屏上扫描有一定的困难。  </li>
<li>从易用性看，<code>qrcode</code>为ES Module的方式使用，支持<code>Promise</code>和<code>async/await</code>，更加符合现代前端的使用习惯。  </li>
<li>从长期使用看，<code>qr-image</code>作者已经停止维护，<code>qrcode</code>作者还在继续维护且使用人数更多。  </li>
</ul>
]]></content>
      <categories>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>使用require.context导入多个模块</title>
    <url>/requireContext/</url>
    <content><![CDATA[<h2 id="使用契机"><a href="#使用契机" class="headerlink" title="使用契机"></a>使用契机</h2><p>将API接口文件分模块存放后需要导入统一的入口文件再统一导出，然后在<code>main.js</code>中引用。看着分门别类的接口文件很舒服，但是文件一多，导入统一入口文件<code>index.js</code>就显得很繁琐。效果如下:  </p>
<p><img src="https://ftp.bmp.ovh/imgs/2020/10/76da31964bce1579.png" alt="api文件列表"></p>
<p><img src="https://ftp.bmp.ovh/imgs/2020/10/44989b9516d6df61.png" alt="导入列表">  </p>
<p><img src="https://ftp.bmp.ovh/imgs/2020/10/e18f9f04cb0884cf.png" alt="导入列表"></p>
<p>说实话，这个看着越看越反人类。所以决定用更简洁的<code>require.context</code>来处理这个问题。  </p>
<h2 id="require-context"><a href="#require-context" class="headerlink" title="require.context"></a>require.context</h2><p><code>require.context</code>是一个<code>webpack</code>的<code>api</code>,通过执行<code>require.context函数</code>获取一个特定的上下文,主要用来实现自动化导入模块,在前端工程中,如果遇到从一个文件夹引入很多模块的情况,可以使用这个<code>api</code>,它会遍历文件夹中的指定文件,然后自动导入,使得不需要每次显式的调用<code>import</code>导入模块  </p>
<p><code>require.context函数</code>接受三个参数</p>
<ul>
<li><p><code>directory &#123;String&#125;</code> -读取文件的路径</p>
</li>
<li><p><code>useSubdirectories &#123;Boolean&#125;</code> -是否遍历文件的子目录</p>
</li>
<li><p><code>regExp &#123;RegExp&#125;</code> -匹配文件的正则</p>
</li>
</ul>
<p>webpack官网给出的例子是这样的:  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span>.context(<span class="string">&#x27;./test&#x27;</span>, <span class="literal">false</span>, <span class="regexp">/.test.js$/</span>)</span><br></pre></td></tr></table></figure>

<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>首先根据需要让<code>require.context</code>遍历<code>/src/api</code>目录。遍历的过程中肯定会把index.js也遍历进去，因为不想之后来处理遍历后的结果，所以先粗暴的用名称区分。  </p>
<p>我将以前的模块名.js改成为了模块名.api.js。  </p>
<p><img src="https://ftp.bmp.ovh/imgs/2020/10/f57afe8c22ddd303.png" alt="api文件列表"></p>
<p>接着开始编写一个导入函数来处理<code>require.context</code>返回的结果。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// importAllModule.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description </span>批量导入API</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>context 上下文对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;RegExp&#125;</span> </span>reg 匹配规则</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Object&#125;</span> </span>对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">importAllModule</span>(<span class="params">context, reg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> map = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> tmp = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> context.keys()) &#123;</span><br><span class="line">        <span class="keyword">const</span> keyArr = key.split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        keyArr.shift()</span><br><span class="line">        map[keyArr.join(<span class="string">&#x27;.&#x27;</span>).replace(reg, <span class="string">&#x27;&#x27;</span>)] = context(key).default</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> map) &#123;</span><br><span class="line">        tmp = &#123;</span><br><span class="line">            ...tmp,</span><br><span class="line">            ...map[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> importAllModule </span><br></pre></td></tr></table></figure>
<p>接着在<code>index.js</code>中导入<code>importAllModule.js</code>并调用导入函数。  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> importAllModule <span class="keyword">from</span> <span class="string">&#x27;../common/js/importAllModule&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> api = importAllModule(<span class="built_in">require</span>.context(<span class="string">&#x27;api&#x27;</span>, <span class="literal">true</span>, <span class="regexp">/\.api.js$/</span>), <span class="regexp">/\.api.js$/g</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> api</span><br></pre></td></tr></table></figure>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>经过<code>require.context</code>的改造，大大解放了生产力。首先是index.js变得更加的简洁和可维护。其次，只要按格式编写API文件的文件名，就会被<code>require.context</code>遍历到并导入到<code>index.js</code>中。</p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>commonJS</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
</search>
